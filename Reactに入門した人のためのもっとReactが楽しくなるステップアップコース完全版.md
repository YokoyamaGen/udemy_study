
 ## レンダリングの最適化
 - 親コンポーネントから子のコンポーネントにpropsされるたびに再レンダリングされるので、propsに渡される値が変更した時だけ再レンダリングするにはmemoという機能を使用する。
 - propsでは関数も渡せる。アロー関数をpropsで渡すと新しい値と子供のコンポーネントは認識して再レンダリングされるため、useCallbackを使用することで、同じ関数だった場合、再レンダリングしないようにする。

## CSSの適応方法
- Inline Stylesはコンポーネントの中にcssを記述する。style属性を定義する際に使用する。普通のcssとは違う書き方。例えば、fontSizeみたいに書かなければならない。
- CSS Modulesはコンポーネントとは別のファイルにcssを記述して、コンポーネントでインポートして使用する。scssを使用できたり、普通のscssと同じ書き方で使用できる。
- Styled JsxはNext.jsでデフォルトでインポートされている。コンポーネントの中でcssを記述する。書き方は普通のcssの書き方で書ける。

## React Router
- 画面遷移で使用するライブラリ。
- `link to`で画面遷移先を指定。aタグみたいなもの。
- `Switch`の中でどのパスにどのコンポーネントを遷移させるかを定義する。exactでパスの完全一致にする。
- URLパラメーターも実装できる。`/test/11`みたいな感じでidをパラメーターとして渡すこともできる。画面遷移先のコンポーネントでURLパラメーターの値を受け取るにはuseParams
- URLのネストも定義できる。`/page1/page1_detail`みたいな感じで。
- クエリパラメーターも扱うことができる。`/test/11?name=hogehoge`の?以降の値をクエリパラメーターという。
- link以外にも画面遷移をする方法として、useHistoryを使用する。そうすれば、javascriptの関数でページ遷移できる。

## Atomicデザイン
- Atomはボタンだけ、インプットボックスだけみたいな最小の粒度
- Moleculeはボタン + インプットボックスみたいな粒度。AtomとAtomを組み合わせたもの。
- Organismはヘッダーやフッター、カートなどの粒度のコンポーネント。AtomやMoleculeを組み合わせたもの。
- Templateはヘッダーやフッターのコンポーネントを呼び出しているコンポーネントぐらいの粒度
- Pagesは最終的に表示される一画面。

## グローバルなstate管理
- stateを何度もpropsするのは辛くなってしまうので、グローバルなstateを使用する。
- ReactではContextやRecoilを使用する。Vue.jsのVuexみたいなイメージ
- 注意点として、stateを更新するとcontextを使用しているコンポーネントやそのコンポーネントが再レンダリングされる。そのため、memoで再レンダリングされないようにしておく。
- Recoilの方がContextよりも少ない記述で書ける。また、更新用の関数だけ、参照用の関数だけをコンポーネント内で使用できるため、更新用だけの関数を使用しているコンポーネントには再レンダリングは発生しない。
