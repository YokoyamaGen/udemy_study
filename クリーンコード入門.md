## 識別子とケース

- クリーンコードとコメント

コメントは必要最小限にする。なぜならコメントを書くとメンテナンスが必要になるため。コメントとコードの挙動があっていないことがあるため、混乱を招く可能性がある。

Gitでコードのコメントを残すことができるため、どういった意図で書いたコードなのかがわかるようになってきたため、なるべくコメントは書かない。

コメントコードの意図を伝えるよりもコードを読めばどういった意図なのかを伝えるようにするのが現在のトレンド

- クリーンコードが優先されないケース

パフォーマンスが優先されるケース。パフォーマンスがよいコードときれいなコードはイコールではない。読みづらいがパフォーマンスがよいコードもあるため。また、開発速度を優先する場合。きれいなコードを書くよりもスピード重視の場合。きれいなコードを書くためにはレビューをしっかりと行い、レビューでの指摘を反映されたりとそれなりに時間がかかる。

識別子（変数名、関数名、クラス名などの識別するためのもの。）のケースの種類について学びましょう。
識別子に名前を付けることを命名と言います。
識別子の命名規則については主に４種類の方法に分類されます。

- ケバブケース
- スネークケース
- パスカルケース
- キャメルケース

### ケバブケース

単語と単語の間をハイフンでつなぐ命名規則。

```
kebab-case
class-name
data-attribute

```

### 使用ケース

HTML 属性（id、class、name...）、URL パス
※ 変数名には使用しないことが多い。

```
<input name="user-name" />
<section class="content-width">...</section>

```

```
<https://example.com/sales-profit>
<https://example.com/post-132>

```

### スネークケース

単語と単語の間をアンダースコアでつなぐ命名規則。

**使用ケース**
(ローカル)変数名
関数名
定数
URL パス
DB のテーブル名、カラム名など
※ クラスには使用しない

```
snake_case
user_id
request_operation_log()
var_dump()
merge_ordered()

```

### アッパースネークケース（コンスタントケース）

大文字をアンダーバーでつなぐ命名規則。

### 使用ケース

主に定数に使用する。

```
USER_NAME
FIREBASE_API_KEY

```

### パスカルケース

単語の先頭を大文字にする命名規則。
アッパーキャメルケースともいう。

### 使用ケース

**クラスやインターフェースに対して使用します。**

```
PascalCase
Users
MyClass

```

### キャメルケース

先頭の単語は小文字、後に続く単語の先頭を大文字にする命名規則。
ローワーキャメルケースともいう。

### 使用ケース

変数やプロパティ名に使用することが多い。

```
camelCase
bookTitle
getName

```

- 変数名はスネークケース、または、キャメルケースでネーミングを付ける。また、変数名をつける際には単語は2〜3つ。
- 真偽値はtrueになった時を命名にする。例えば、age > 20だったら、「is_adult」 とする。20歳以上だったら、成人なので。真偽値の変数を命名する際には先頭にis~をつけることや過去分詞(completed、done、finished)などで命名する。
- 真偽値を返す関数名は先頭にcan、is、hasなどをつける。ただし、existは自動詞のため、existsとする。また、命名に困った際には世の中に出ているAPIでどのように命名されているのかを参考にする。

# セクション5 関数の定義

## 関数はなるべく小さく1つの責務のみ行う

- 複数の責務をもたせると複雑になり、読みにくい。例えば、1つのバリデーション関数の中にメールや名前、電話番号の処理を書くのではなく、それぞれのバリデーション関数を定義する。
- 1つの関数にデータを取得する処理、データを送信する処理の2つの処理を書くなら、データを取得する処理で1つの関数を定義する。また、データを送信する処理で1つの関数を定義する。それぞれを呼び出す関数を定義することで読みやすくなる。
- 以下のような関数の中にある`birthday.match(/^\d{4}-\d{2}-\d{2}$/)`だけを関数化する。そうすれば今後、他のコードを書く時に使い回せる可能性が高いため。以下のすべてを関数化すると使いまわしづらい。一行でもいいので、使い回せるように関数として切り出す。

```jsx
if (!birthday.match(/^\d{4}-\d{2}-\d{2}$/)) {
    throw new Error(`誕生日のフォーマットが正しくありません。[${birthday}]`);
  }
```

## DRYを適用しないほうがよい場合

- 関数の中に書かかれている処理内容が同じでも目的が異なるものはDRYにしない。共通化すると片方の目的には使用されないデットコードがでてくる。将来的にスパゲッティーコードになるため、目的が異なる関数は共通化しないで別の関数とする。例えば、税金を金額を出すコードと違約金を出すコード。

## 関数の中に条件分岐をできるだけ書かない。関数の引数にboolean値を渡さない。

- 関数の中に条件分岐を書くと、責務が不明確になってしまい、追いづらいコードになってしまうため。関数の中で条件分岐をせず、関数の呼び出し元で条件分岐をする。

# セクション7 条件分岐

## 早期リターンを使用する

- if文の中身が一行なら、`if(条件式) 処理`のように一行で書ける。
- 条件式でtrue、falseを返却するのに`return A > B`みたいに書ける。

## 境界条件のカプセル化

- `if(width / 2 < 100)`みたいに書くと、`width / 2`が何を指しているのかが分かりづらいので、`const width_half = width / 2`みたいに変数に格納して、`if(width_half < 100)`のようにすると読みやすくなる。

## 複雑な条件はメソッド化する

`if(A === ‘hoge’ && B != ‘fuga’ || C === 1 )`だと可読性が悪いので、`function isUnLucky(){A === ‘hoge’ && B != ‘fuga’ || C === 1}`という関数を定義して、`if(isUnLucky())`とした方が読みやすい。

## 条件式の左に定数を配置する

- `if (A = “aa”)`とすると代入となってしまうが、`if (“aa” = A)`とすればエラーになり、タイポに気づける。また、目的が先にくるため、読みやすくなる。

# セクション8 クラス

## 凝集度を高めよう

- クラスの中でデータとそのデータを使用しているメソッドが近い場所に定義されているかどうかを表す指標のことを凝集度という。
- なるべくクラスの中で定義したデータとメソッドを一緒に書くと保守性が高い高凝集のコードを書く。

## 結合度を疎にする

- クラス同士が関係性が強い状態を密結合という。片方のクラスを変更するともう片方のクラスも変更しなければならない関係性は保守性が低い。そのため、クラス同士の関係性を低くする疎結合にする。そのためにクラスを高凝集な作りする。クラスに定義したデータとそのデータを使用するメソッドを同じクラスに定義する。

## クラスの内部情報はなるべく隠蔽する

- インスタンス変数はなるべくプライベートにして意図しない変更を避けるようにする。変更や取得する際にはgetterやsetterを定義して、値を変個する。

## クラス継承とコンポジション

- dog is an animalのようにdogクラスはanimalクラスを継承している場合、継承(is a)という。
    - 設計する際に十分に検討して使用する。設計が破綻する可能性がある。
    - 親クラスのメソッドを子供はすべて使用できる。
    - 複数の親を継承できない。
- television has a switchのようにtelevisionがswitchクラスを所有している関係をコンポジション(has a)関係という。
    - 所有しているクラスのすべてのメソッドを使用できるわけではない。
    - 継承よりも柔軟性があるものの、メソッドが多くなり、複雑になりやすい。
